from fastapi import FastAPI
from pydantic import BaseModel
import os
import datetime

app = FastAPI()


@app.get("/")
def read_root():
    return {"name": "measurement unit converter",
            "description": "API to convert between various measurement units, and back."}


class Converter(BaseModel):
    cellsius: float
    fahrenheit: float


def c2f(c: float):
    return (c * 9 / 5) + 32


def f2c(f: float):
    return (f - 32) * 5 / 9


@app.get("/")
async def read_root():
    """The index route should always be available, but not always functional"""
    return {"msg": "A simple temperature converter API. See /docs page, autogenerated by FastAPI for more details."}


@app.get("/celsius/{degree}")
def convert_celsius(degree: float) -> Converter:
    """Convert from Celsius to Fahrenheit"""
    return Converter(cellsius=degree, fahrenheit=c2f(degree))


@app.get("/fahrenheit/{degree}")
def convert_fahrenheit(degree: float):
    """Convert from Fahrenhei to Celsius"""
    return Converter(cellsius=f2c(degree), fahrenheit=degree)


@app.get('/exception')
async def thrown_an_exception():
    """
    Generate an exception, by opening a non-existing file, and handle it.
     Return success all the time.
     This is just to test backend functionality
    """
    error_message = "Default error message."
    try:
        my_file = open("missing_file.txt", "r", encoding="UTF-8")
        # do some file operations

        #  the file will be closed no matter what
        my_file.close()
        # Always a good idea to close resources that may or maynot have been left open

    except FileNotFoundError:
        error_message = "File not found."
    except PermissionError:
        error_message = "Permission denied."
    # finally:
    #     error_message = "File closed. No error"

    return {"msg": error_message}


def divide(a, b):
    """Demonstrate throwing our own exception """
    if b == 0:
        raise ZeroDivisionError("Cannot divide by zero.")
    return a / b


@app.get('/myownexception')
async def throw_myown_exception():
    try:
        # To generate our own thrown exception
        result = divide(5, 0)
        print(result)
    except ZeroDivisionError as e:
        print(e)

    return "completed"


@app.get('/error')
async def error():
    """This should throw an error"""
    return divide(5, 0)


@app.get('/health')
async def health():
    """Return a 200, indicating that everything is healthy."""
    # TODO: Should be more intelligent, for AWS and Prometheus monitoring
    return datetime.datetime.now()


@app.get('/info')
async def info():
    """Return OS and platform information."""
    import platform
    return {
        "os_name": os.name,
        "platform_system": platform.system(),
        "platform_release": platform.release(),
        "platform_version": platform.version(),
        "platform_machine": platform.machine(),
        "platform_processor": platform.processor(),
        "platform_python_build": platform.python_build(),
        "platform_python_version": platform.python_version(),
    }
